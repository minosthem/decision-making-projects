# Assignment 1

## Part 1: SKP - Problem instances generation

For this part, we have created two classes to model the requirements of the assignment. The first class is called ProblemInstance to represent the generated instance and has only one field, i.e. a list with the generated items of this specific problem instance. Moreover, the second class is the Item class. The fields in this class are: the two possible sizes (i.e. dl and dh), the final size (based on the calculated probability), the probability pi and the ri. All the classes can be found in Assignment1/models package.

The file main.py is used to call all the necessary methods from the other python files. The code for this question can be found in Assignment1/questions/part1.py. The method generate_problem_instances is used to create 10 problem instances with 10 items each. For each item, dli, dhi, pi and ri are calculated and save in the respective fields of the Item object. In order to decide the size that should be assigned to the item, we use Bernoulli distribution and based on the result (0 or 1), d_l or d_h size is selected. All problem instances are save into a list which is then returned to the main program. For poisson and triangular distributions, numpy library is used (numpy.random.poisson and numpy.random.triangular) in order to generate random numbers for the items' sizes.


## Part 2 and 3: Heuristic Algorithm and Monte Carlo

This heuristic algorithm tries to find which items will be assigned to the knapsack regarding their value and size and with respect to the capacity constraint. The main program uses the function run_knapsack_for_problem_instance to execute parts 2 and 3. As input, one problem instance (in order to aquire the relevant items) and the capacity should be provided. The knapsack algorithm creates two tables, with size (number_of_items +1, capacity + 1). The first table is used for storing the value of the items included in the knapsack and the second one defines if an item is included. Then, the algorithm iterates the first table and performs two checks:
	* The size of the item does not exeed the current capacity (defined by the column in the iteration)
	* The revenue of the item plus the revenue stored in the previous row of the table and in the column related to the current capacity minus the capacity of the new item should be greater than the revenue of the previous state ((vi + table[i - 1, w - wi] > table[i - 1, w]))
When the above condition is true, the revenue stored in the first table takes the value of the new item's revenue plus the revenue in table[i-1, w-wi] and the relevant position in the second table takes the value 1 (the item is kept). After the table iteration is finished, we start a new iteraction from the bottom row and with the max capacity in order to collect the items that should be included in the knapsack with respect to the remaining capacity. Finally, the algorithm returns the items and the total revenue.
Based on the result of the knapsack problem, we define a new field of the Item objects, i.e. the decision_variable, which takes values 0 or 1 (by checking if the respective item is selected or not). Then, we run a monte carlo simulation. We use bernoulli distribution to decide if an item is included in the knapsack or not. Moreover, we iterate the item list and if the item is selected and the capacity is not exceeded then we take into account the revenue of the new item, otherwise we count the items that are seleted by Bernoulli distribution but they do not fit in the knapsack. For each run of the monte carlo simulation, we calculate the profit, i.e. total revenue minus the penalty for each item that does not fit. Finally, we calculate the average profit, standard deviation and the confidence interval.
\documentclass[12pt]{article}

\usepackage{float}
\usepackage[english]{babel}
\usepackage[square,numbers]{natbib}
\bibliographystyle{abbrvnat}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfig}
\graphicspath{{images/}}
%\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\hypersetup{
	colorlinks,
	citecolor=blue,
	%filecolor=black,
	linkcolor=black,
	urlcolor=blue
}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}
\usepackage[table]{xcolor}
\usepackage{todonotes}
\usepackage{menukeys}
\usepackage[toc,page]{appendix}
\usepackage{indentfirst}

\setlength\parindent{24pt}

\title{Assignment 1}   
% Title
\author{ Dafni Lappa, 2032943 \\
	Epaminondas - Spyridon Themelis, 2030983}          % Authors
\date{\today}                                          % Date

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
%\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

\begin{document}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\begin{titlepage}
		\centering
		\vspace*{0.5 cm}
		\includegraphics[scale = 0.75]{logo.png}\\[1.0 cm]   % University Logo
		\textsc{\LARGE Tilburg University}\\[2.0 cm]   % University Name
		\textsc{\Large M.Sc. Business Analytics and Operations Research}\\[0.5 cm]               % Department
		\textsc{\large Decision Making under Uncertainty}\\[0.5 cm]               % Course Name
		\rule{\linewidth}{0.2 mm} \\[0.4 cm]
		{ \huge \bfseries \thetitle}\\
		\rule{\linewidth}{0.2 mm} \\[1.5 cm]
		
		\begin{minipage}{0.4\textwidth}
			\begin{center} \large
				\theauthor
			\end{center}
		\end{minipage}~
		\begin{minipage}{0.4\textwidth}
		\end{minipage}\\[2 cm]
		
		{\large \thedate}\\[2 cm]
		
		\vfill
		
	\end{titlepage}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\tableofcontents
	\newpage
	\listoffigures
	\newpage
	\listoftables
	\newpage
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\section{Introduction}
	
	Our team (group 10) members are Dafni Lappa and Epameinondas-Spyridon Themelis. We implemented the assignment in Python 3.7, using numpy, scipy, gurobipy libraries among others. The code is available in our GitHub repository\footnote{https://github.com/minosthem/decision-making-projects} inside the folder Assignment1. 
	
	The file main.py is used to call all the necessary methods from the other python files. All the classes we have created to model our problem are under package models, while the code implementing the respective parts can be found in package questions.
	
	In the following sections, we will provide an in depth analysis of our implementation and explanations on our results.

    \section{Knapsack problem and Monte Carlo simulation}
    
    The Knapsack problem is a resource allocation problem which determines the number of items to be included in a knapsack given its capacity and items' sizes and values. The objective is to maximize the gained value from the included items and do not exceed the knapsack's capacity.
    
    Monte Carlo simulation is a technique used in order to understand the impact of risk and uncertainty in a predictive model. This method is used to model the probability of different outcomes by randomizing the input variables. 
    
    \subsection{Part 1 - Generation of Problem Instances}
    
    We have decided to represent problem instances and items using objects. Therefore, in the package models, we include all the classes created for model representation. ProblemInstance class represents a generated instance, with a list of items as field. This list contains objects of type Item, which is the second class we have created. This class represents an item of a problem instance. The fields in this class are: the two possible sizes (i.e. dl and dh), the final size (based on the calculated probability), the probability pi and the revenue ri.
    
    The implementation of problem instances generation can be found in questions/part1.py. The method generate\_problem\_instances, creates 10 ProblemInstances with 10 items each. For each item, we calculate the pi probability, the dl and dh size based on random values generated by Poisson and Triangular distributions (from numpy library) respectively. Additionally, we have calculated the item's size based on the probability pi and dl, dh values and assigned the item's revenue to the respective field. All problem instances are then stored in a list, returned to the main function to be used in the following parts.

    \subsection{Part 2 - Heuristic Algorithm}
    
    The implementation of Knapsack Problem algorithm as well as the Monte Carlo simulation can be found in questions/part2And3.py file. Main function uses run\_knapsack\_for\_problem\_instance to execute Knapsack algorithm and Monte Carlo simulation for the first problem instance. The function knapsack\_dp contains the algorithm's code and expects a list with tuples, where each tuple contains an item's revenue, size and position in the list. We use the function reform\_items to create this list from the item objects list.
    
    Knapsack algorithm tries to find which items will be assigned to the knapsack regarding their value and size and with respect to the capacity constraint. The knapsack algorithm creates two tables, with size (number\_of\_items +1, capacity + 1). The first table is used for storing the value of the items included in the knapsack and the second one defines if an item is included. Then, the algorithm iterates the first table and performs two checks:
    
    \begin{itemize}
        \item  The size of the item does not exeed the current capacity (defined by the column in the iteration)
        \item The revenue of the item plus the revenue stored in the previous row of the table and in the column related to the current capacity minus the capacity of the new item should be greater than the revenue of the previous state $((v_i + table[i - 1, w - w_i] > table[i - 1, w]))$
    \end{itemize}

When the above conditions are true, the revenue stored in the first table takes the value of the new item's revenue plus the revenue in $table[i-1, w-w_i]$ and the relevant position in the second table takes the value 1 (i.e. the item is kept). After the table iteration is finished, we start a new iteration from the bottom row and with the max capacity in order to collect the items that should be included in the knapsack with respect to the remaining capacity. Finally, the algorithm returns the items and the total revenue.
    
    \subsection{Part 3 - Monte Carlo Simulation}
    
    Based on the result of the knapsack problem, we define a new field of the Item objects, i.e. the decision\_variable, which takes values 0 or 1 (by checking if the respective item is selected or not). Then, we run a monte carlo simulation using the function monte\_carlo in part2And3.py file. In models package, we have created a classed named MonteCarloSim, to model a specific run of the Monte Carlo Simulation. The fields of the class are: the number of the run associated with the object, a list with the Item objects included in the knapsack and the profit of the specific run.
    
    To begin with, we execute monte\_carlo function for a small number of runs (e.g. 100) to find out the standard deviation. Inside the monte\_carlo function, for each selected item (by the Knapsack algorithm) we generate a random number, 0 or 1, using Bernoulli distribution from numpy library with probability the item's $p_i$ probability. In this way, we select the dl or dh size for a specific item. Then, we check which items can be included in the knapsack, taking into account their revenue multiplied by their size, and for the remaining items we apply a penalty. The run's profit is calculated using the total revenue minus the penalty multiplied with the total extra size that does not fit in the knapsack.
    
    All the profits are stored in a list, based on which we calculate the mean, standard deviation and confidence interval of the profits. Using the standard deviation, we calculate a new number of Monte Carlo runs using the type:
    
    $$ (\frac{1.96 * Sn}{10 ^ {-2}})^ 2 $$
    
    Now, we use again monte\_carlo function with a new number of runs and we get a new list of profits. As we did for the small number of runs, we calculate the mean, the standard deviation and the confidence interval of the profits. The confidence interval is calculated using the below types:
    
    $$ halfWidth = \frac{1.96 * Sn}{\sqrt{runs}} $$
    
    $$ confidenceInterval = (mean - halfWidth, mean + halfWidth) $$
    
    \section{Stochastic Programming Models}
    
    \subsection{Part 4 - Our model}
    
    \subsection{Part 5 - Run our model with gurobi}
    
    \subsection{Part 6}
    
    \section{Sample Average Approximation - Part 7}
    
    \section{Analysis}
    
    \subsection{Part 8}
    
    \subsection{Part 9}
    
    \subsection{Bonus}
    
	\begin{appendices}
    
        \section{Appendix A}
        
    \end{appendices}
\end{document}
